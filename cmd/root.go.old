package cmd

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha512"
	"encoding/binary"
	"fmt"
	"io"
	"math/big"
	"os"

	"github.com/conradludgate/pass/pass"
	"github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "pass",
	Short: "Phone authenticated password manager",

	Run: pair,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func pair(cmd *cobra.Command, args []string) {
	fmt.Println("Pairing...")

	file, err := os.OpenFile(os.Getenv("PASS_KEY_FILE"), os.O_CREATE|os.O_RDWR, 0600)
	if err != nil {
		file, err = os.OpenFile(".pass.key", os.O_CREATE|os.O_RDWR, 0600)
		if err != nil {
			fmt.Println("Cannot open file. Reason:", err.Error())
		}
	}
	defer file.Close()

	fmt.Println(file.Name())

	var priv *rsa.PrivateKey

	var size int16
	if err := binary.Read(file, binary.BigEndian, &size); err == nil {
		priv_hash := make([]byte, size)
		if _, err = file.Read(priv_hash); err == nil {
			fmt.Println("sum", string(priv_hash))
			fmt.Println("Attempting to get key")
			var sum []byte
			priv, sum = get_priv(file)

			if priv != nil && !verify_priv(priv, priv_hash, sum) {
				fmt.Println("Bad private key")
				priv = nil
			}
		}
	}

	if priv == nil {
		fmt.Println("Generating key")
		priv, err = rsa.GenerateKey(rand.Reader, 512)
		if err != nil {
			fmt.Println("Error generating new RSA Key. Reason:", err.Error())
		}

		hash := sha512.New()

		E := &bytes.Buffer{}
		binary.Write(E, binary.BigEndian, priv.E)

		N := priv.N.Bytes()
		binary.Write(E, binary.BigEndian, int16(len(N)))
		E.Write(N)
		hash.Sum(N)

		D := priv.D.Bytes()
		binary.Write(E, binary.BigEndian, int16(len(D)))
		E.Write(D)
		hash.Sum(D)

		var sum []byte
		var primes []byte
		for _, prime := range priv.Primes {
			prime_bytes := prime.Bytes()
			primes = append(primes, prime_bytes...)

			binary.Write(E, binary.BigEndian, int16(len(prime_bytes)))
			E.Write(prime_bytes)

			sum = hash.Sum(prime_bytes)
		}

		fmt.Println("sum", string(sum))

		binary.Write(file, binary.BigEndian, int16(len(sum)))
		file.Write(sum)
		file.Write(E.Bytes())
	}

	pass.Pair(priv)
}

func get_priv(r io.Reader) (priv *rsa.PrivateKey, sum []byte) {
	priv = &rsa.PrivateKey{}
	hash := sha512.New()

	var E int32
	if err := binary.Read(r, binary.BigEndian, &E); err != nil {
		fmt.Println("E: " + err.Error())
		return nil, nil
	}
	priv.E = int(E)

	var size int16
	if err := binary.Read(r, binary.BigEndian, &size); err != nil {
		fmt.Println("N size: " + err.Error())
		return nil, nil
	}

	fmt.Println(size)
	N := make([]byte, size)
	_, err := r.Read(N)
	if err != nil {
		fmt.Println("N: " + err.Error())
		return nil, nil
	}
	priv.N = (&big.Int{}).SetBytes(N)
	hash.Sum(N)

	if err = binary.Read(r, binary.BigEndian, &size); err != nil {
		fmt.Println("D size: " + err.Error())
		return nil, nil
	}

	D := make([]byte, size)
	_, err = r.Read(D)
	if err != nil {
		fmt.Println("D: " + err.Error())
		return nil, nil
	}
	priv.D = (&big.Int{}).SetBytes(D)
	hash.Sum(D)

	for {
		err = binary.Read(r, binary.BigEndian, &size)
		if err != nil {
			break
		}

		D := make([]byte, size)
		_, err = r.Read(D)
		if err != nil {
			break
		}
		priv.Primes = append(priv.Primes, (&big.Int{}).SetBytes(D))
		sum = hash.Sum(D)
	}

	if err == io.EOF {
		return
	}

	fmt.Println("Primes: " + err.Error())
	return nil, nil
}

func verify_priv(priv *rsa.PrivateKey, hash, sum []byte) bool {
	if len(sum) != len(hash) {
		fmt.Println("Bad checksum length")
		return false
	}

	for i, v := range sum {
		if hash[i] != v {
			fmt.Println("Bad checksum")
			return false
		}
	}

	return priv.Validate() == nil
}
